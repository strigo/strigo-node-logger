const isPlainObject = require('lodash.isplainobject');

const { ECS_RESERVED } = require('./constants');

/**
 * A replacer function for JSON.stringify. Will remove any empty objects in root of object
 *
 */
function removeEmpty(key, value) {
  if (value === null || typeof value !== 'object') return value;
  return Object.keys(value).length === 0 ? undefined : value;
}

function removeReservedOrEmpty(key, value) {
  if (['level', 'message', 'timestamp', 'splat'].includes(key)) return undefined;
  return removeEmpty(key, value);
}

function requestsFilter(matchers) {
  return (req, res) => {
    const userAgent = req.headers['user-agent'] || '';

    return matchers.some(
      ({ agent, urls, statuses }) => userAgent.includes(agent)
        && urls.includes(req.url)
        && statuses.includes(res.statusCode),
    );
  };
}


function ecsMeta(req, res, err) {
  const whitelistedHeaders = [
    'x-forwarded-for',
    'x-forwarded-proto',
    'content-type',
  ];

  const meta = {
    http: {
      protocol: req.httpVersion,
      request: {
        method: req.method.toLowerCase(),
        bytes: req.socket.bytesRead,
      },
    },
    url: {
      original: req.originalUrl,
      scheme: req.protocol,
    },
    client: {
      ip: req.ip,
      port: req.socket.remotePort,
    },
    server: {
      ip: req.socket.localAddress,
      port: req.socket.localPort,
    },
  };

  if (req.headers) {
    if (req.headers.referer) {
      meta.http.request.referer = req.headers.referer;
    }

    if (req.headers['content-length']) {
      meta.http.request.body = {
        bytes: req.headers['content-length'],
      };
    }

    if (req.headers['user-agent']) {
      meta.user_agent = {
        original: req.headers['user-agent'],
      };
    }

    whitelistedHeaders.forEach((header) => {
      if (req.headers[header]) {
        meta.http.request.headers = meta.http.request.headers || {};
        meta.http.request.headers[header] = req.headers[header];
      }
    });
  }

  if (req.hostname) {
    const [host, port] = req.hostname.split(':');
    meta.url.domain = host;
    if (port) meta.url.port = Number(port);
  }

  if (req.ctx && isPlainObject(req.ctx)) {
    Object.entries(req.ctx).forEach(([key, value]) => {
      // Exclude ECS reserved fields and ensure that the value is defined
      // (double equal sign is intentional) and has primitive value (number, string, boolean)
      // to avoid complex log structures.
      if (!ECS_RESERVED.includes(key) && value != null && Object(value) !== value) {
        meta[key] = value;
      }
    });
  }

  // during error handling, the res part is meaningless.
  // the actual return code and duration are logged in the regular http log
  if (res && !err) {
    meta.http = {
      response: {
        status_code: res.statusCode,
      },
      event: {
        duration_ms: res.responseTime,
      },
    };
  }

  if (err) {
    meta.error = {
      type: err.name,
      message: err.message,
      stack_trace: err.stack,
    };
  }

  return meta;
}


module.exports = {
  removeEmpty,
  removeReservedOrEmpty,
  requestsFilter,
  ecsMeta,
};
